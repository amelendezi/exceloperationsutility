<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Excel File Processor</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f4f4f4;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .tab-container {
      overflow: hidden;
      background-color: #ddd;
      border-radius: 8px 8px 0 0;
      height: 46px;
    }
    .tab-container button {
      background-color: #FFF9C4;
      border: none;
      outline: none;
      cursor: pointer;
      padding: 14px 16px;
      transition: 0.3s;
      font-size: 16px;
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      width: 120px;
      float: left;
      margin-right: 2px;
      text-align: center;
    }
    .tab-container button.file-selection-tab {
      width: 180px;
    }
    .tab-container button:hover {
      background-color: #FFECB3;
    }
    .tab-container button.active {
      background-color: #FFC107;
      color: white;
    }
    .tab-container button.data-tab {
      display: none;
      background-color: #C8E6C9;
      color: #333;
    }
    .tab-container button.data-tab:hover {
      background-color: #B2DFDB;
    }
    .tab-container button.data-tab.active {
      background-color: #4CAF50;
      color: white;
    }
    .tab-content {
      display: none;
      padding: 20px;
      background-color: white;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .tab-content.active {
      display: block;
    }
    .upload-container {
      background-color: white;
      padding: 20px;
    }
    .instructions {
      margin-bottom: 20px;
      color: #333;
      line-height: 1.6;
    }
    .file-input {
      margin: 20px 0;
      display: block;
      position: relative;
    }
    .file-input-table {
      width: 100%;
      border-collapse: collapse;
    }
    .file-input-table td {
      padding: 10px 20px 10px 0;
      vertical-align: middle;
    }
    input[type="file"] {
      font-size: 14px;
      color: #333;
    }
    input[type="file"]::-webkit-file-upload-button {
      background-color: #B0C4DE;
      padding: 8px 12px;
      border-radius: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: none;
      cursor: pointer;
      color: #333;
      font-size: 14px;
    }
    input[type="file"]::-webkit-file-upload-button:hover {
      background-color: #A3BFFA;
    }
    .check-mark {
      color: #3c763d;
      font-size: 16px;
      margin-left: 10px;
      display: none;
    }
    .drag-area {
      border: 2px dashed #B0C4DE;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #666;
      font-size: 14px;
      margin-top: 10px;
      cursor: pointer;
      transition: background-color: 0.3s;
    }
    .drag-area.drag-over {
      background-color: #E6EFFF;
    }
    .schema-box {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      text-align: left;
      font-size: 14px;
      border: none;
      display: none;
    }
    .schema-box.processed {
      border: 1px solid: #ccc;
      display: block;
    }
    .warning {
      color: #e65100;
      margin-bottom: 10px;
    }
    .warning-detail {
      color: #e65100;
      margin-top: 5px;
      margin-left: 20px;
    }
    .error {
      color: #a94442;
      margin-bottom: 10px;
    }
    .schema-table {
      width: 100%;
      border-collapse: collapse;
    }
    .schema-table th, .schema-table td {
      padding: 8px;
      text-align: left;
      color: #666;
    }
    .schema-table th {
      font-weight: bold;
      color: #333;
      vertical-align: middle;
    }
    .schema-table td.different {
      color: #a94442;
      font-weight: bold;
    }
    .edit-icon {
      cursor: pointer;
      color: #2196F3;
      margin-left: 5px;
      font-size: 12px;
    }
    .key-icon {
      color: #666;
      margin-left: 5px;
      font-size: 14px;
    }
    .save-button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-bottom: 10px;
    }
    .save-button:hover {
      background-color: #388E3C;
    }
    .checkbox-cell {
      width: 30px;
      text-align: center;
    }
    .comparison-key-message {
      margin-top: 10px;
      font-size: 12px;
      color: #2196F3;
    }
    .sub-tab-container {
      overflow: hidden;
      background-color: #ddd;
      border-radius: 0 0 6px 6px;
      height: 38px;
      margin-bottom: 10px;
    }
    .sub-tab-container button {
      background-color: #e0e0e0;
      border: none;
      outline: none;
      cursor: pointer;
      padding: 10px 12px;
      transition: 0.3s;
      font-size: 14px;
      border-bottom-left-radius: 6px;
      border-bottom-right-radius: 6px;
      width: 100px;
      float: left;
      margin-right: 2px;
      text-align: center;
    }
    .sub-tab-container button:hover {
      background-color: #d0d0d0;
    }
    .sub-tab-container button.active {
      background-color: #2196F3;
      color: white;
    }
    .sub-tab-content {
      display: none;
    }
    .sub-tab-content.active {
      display: block;
    }
    .data-view-box {
      padding: 15px;
      border-radius: 8px;
      border: 1px solid: #ccc;
      background-color: white;
      height: calc(80vh - 160px);
      overflow-y: auto;
      overflow-x: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .data-view-header {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .data-view-header input {
      padding: 8px;
      width: 30%;
      border: 1px solid: #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    .modified-tag, .deleted-tag {
      background-color: #cccccc;
      color: #333;
      border: 1px solid: #999999;
      border-radius: 12px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: background-color: 0.3s;
    }
    .modified-tag.active {
      background-color: #4CAF50;
      color: white;
      border-color: #388E3C;
    }
    .deleted-tag.active {
      background-color: #8B0000;
      color: white;
      border-color: #6B0000;
    }
    .modified-tag:hover {
      background-color: #b3b3b3;
    }
    .deleted-tag:hover {
      background-color: #b3b3b3;
    }
    .modified-tag.active:hover {
      background-color: #388E3C;
    }
    .deleted-tag.active:hover {
      background-color: #6B0000;
    }
    .export-button {
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 12px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      margin-left: auto;
      transition: background-color: 0.3s;
    }
    .export-button:hover {
      background-color: #1976D2;
    }
    .data-table {
      width: 100%;
      border-collapse: collapse;
    }
    .data-table th, .data-table td {
      padding: 8px;
      border: 1px solid: #ddd;
      text-align: left;
      color: #666;
      white-space: nowrap;
    }
    .data-table th {
      background-color: #f4f4f4;
      font-weight: bold;
      color: #333;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .data-table tr.new-row {
      background-color: #FFFF99;
    }
    .data-table tr.deleted-row {
      background-color: #FFE4E4;
    }
    .data-table td.different-value {
      background-color: #FFFF99;
    }
    .highlight {
      background-color: #FFFF99;
    }
  </style>
</head>
<body>
  <h1>Excel File Processor</h1>
  <div class="tab-container">
    <button class="tab-link file-selection-tab active" onclick="openTab(event, 'FileSelection')">File Selection</button>
    <button id="dataTab" class="tab-link data-tab" onclick="openTab(event, 'Data')">Data</button>
  </div>

  <div id="FileSelection" class="tab-content active">
    <div class="upload-container">
      <div class="instructions">
        Please upload two versions of the Excel files: the old version and the new version. 
        Each file must have a first row containing unique column headers. Subsequent rows should contain the data. 
        Only the first sheet of each Excel file will be processed; all other sheets will be discarded.
      </div>
      <table class="file-input-table">
        <tr>
          <td>
            <label for="file1" class="file-input">
              Old File:
              <input type="file" id="file1" accept=".xlsx">
              <span id="check1" class="check-mark">✔</span>
            </label>
            <div id="dragArea1" class="drag-area">Drag file here</div>
          </td>
          <td>
            <label for="file2" class="file-input">
              New File:
              <input type="file" id="file2" accept=".xlsx">
              <span id="check2" class="check-mark">✔</span>
            </label>
            <div id="dragArea2" class="drag-area">Drag file here</div>
          </td>
          <td></td>
        </tr>
      </table>
      <div id="messages"></div>
      <div id="schema" class="schema-box">
        <table id="schema-table" class="schema-table"></table>
        <div id="comparison-key" class="comparison-key-message"></div>
      </div>
    </div>
  </div>
  <div id="Data" class="tab-content">
    <div class="sub-tab-container">
      <button class="sub-tab-link active" onclick="openSubTab(event, 'OldData')">Old Data</button>
      <button class="sub-tab-link" onclick="openSubTab(event, 'NewData')">New Data</button>
    </div>
    <div id="OldData" class="sub-tab-content active">
      <div class="data-view-box">
        <div class="data-view-header">
          <input type="text" id="oldDataSearch" placeholder="Search old data...">
        </div>
        <table id="oldDataTable" class="data-table"></table>
      </div>
    </div>
    <div id="NewData" class="sub-tab-content">
      <div class="data-view-box">
        <div class="data-view-header">
          <input type="text" id="newDataSearch" placeholder="Search new data...">
          <button id="modifiedFilter" class="modified-tag">Modified</button>
          <button id="deletedFilter" class="deleted-tag">Deleted</button>
          <button id="exportButton" class="export-button">Export</button>
        </div>
        <table id="newDataTable" class="data-table"></table>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/xlsx@0.20.3/dist/xlsx.full.min.js"></script>
  <script>
    let data1 = null;
    let data2 = null;
    let comparisonKey = 'Name';
    let isEditing = false;
    let selectedKey = null;
    let showModifiedOnly = false;
    let showDeletedOnly = false;

    // Promise to track SheetJS loading for file reading
    let sheetJSPromise = null;
    function loadSheetJS() {
      if (sheetJSPromise) return sheetJSPromise;
      if (typeof XLSX !== 'undefined') return Promise.resolve();

      sheetJSPromise = new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'js/xlsx.full.min.js';
        script.async = false;
        script.onload = () => {
          if (typeof XLSX !== 'undefined') {
            resolve();
          } else {
            reject(new Error('Failed to load SheetJS from fallback.'));
          }
        };
        script.onerror = () => reject(new Error('Failed to load SheetJS fallback script.'));
        document.head.appendChild(script);
      });

      return sheetJSPromise;
    }

    function hideDataView() {
      document.getElementById('oldDataTable').innerHTML = '';
      document.getElementById('newDataTable').innerHTML = '';
      document.getElementById('oldDataSearch').value = '';
      document.getElementById('newDataSearch').value = '';
    }

    function toggleDataTab(show) {
      const dataTab = document.getElementById('dataTab');
      dataTab.style.display = show ? 'inline-block' : 'none';
    }

    function renderSubTabData(subTabName) {
      if (subTabName === 'OldData' && data1) {
        const headers = Object.keys(data1[0] || {});
        renderDataTable(data1, headers, 'oldDataTable', document.getElementById('oldDataSearch').value);
      } else if (subTabName === 'NewData' && data2) {
        const headers = Object.keys(data2[0] || {});
        renderDataTable(data2, headers, 'newDataTable', document.getElementById('newDataSearch').value, true);
      }
    }

    function openTab(evt, tabName) {
      const tabContents = document.getElementsByClassName("tab-content");
      for (let i = 0; i < tabContents.length; i++) {
        tabContents[i].classList.remove("active");
      }
      const tabLinks = document.getElementsByClassName("tab-link");
      for (let i = 0; i < tabLinks.length; i++) {
        tabLinks[i].classList.remove("active");
      }
      document.getElementById(tabName).classList.add("active");
      evt.currentTarget.classList.add("active");
    }

    function openSubTab(evt, subTabName) {
      const subTabContents = document.getElementsByClassName("sub-tab-content");
      for (let i = 0; i < subTabContents.length; i++) {
        subTabContents[i].classList.remove("active");
      }
      const subTabLinks = document.getElementsByClassName("sub-tab-link");
      for (let i = 0; i < subTabLinks.length; i++) {
        subTabLinks[i].classList.remove("active");
      }
      document.getElementById(subTabName).classList.add("active");
      evt.currentTarget.classList.add("active");
      renderSubTabData(subTabName);
    }

    function updateMessages(messages, isError = false, isWarning = false) {
      const messagesDiv = document.getElementById('messages');
      messagesDiv.innerHTML = '';

      messages.forEach(message => {
        const messageDiv = document.createElement('div');
        messageDiv.textContent = message.message || message;
        if (isError) {
          messageDiv.className = 'error';
        } else if (isWarning) {
          messageDiv.className = message.isDetail ? 'warning-detail' : 'warning';
        }
        messagesDiv.appendChild(messageDiv);
      });
    }

    function updateSchema(headers1, headers2, uniqueToFile1, uniqueToFile2, commonHeaders) {
      const schemaDiv = document.getElementById('schema');
      const schemaTable = document.getElementById('schema-table');
      const comparisonKeyDiv = document.getElementById('comparison-key');
      schemaTable.innerHTML = '';
      schemaDiv.classList.add('processed');

      if (isEditing) {
        const saveRow = document.createElement('tr');
        const saveCell = document.createElement('td');
        saveCell.colSpan = 3;
        const saveButton = document.createElement('button');
        saveButton.className = 'save-button';
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
          if (selectedKey) {
            comparisonKey = selectedKey;
            isEditing = false;
            updateSchema(headers1, headers2, uniqueToFile1, uniqueToFile2, commonHeaders);
            renderSubTabData('NewData');
          } else {
            updateMessages(['Please select a comparison key.'], true);
          }
        };
        saveCell.appendChild(saveButton);
        saveRow.appendChild(saveCell);
        schemaTable.appendChild(saveRow);
      }

      const headerRow = document.createElement('tr');
      const th1 = document.createElement('th');
      const th2 = document.createElement('th');
      th1.textContent = 'Old File Columns';
      th2.textContent = 'New File Columns';
      headerRow.appendChild(th1);
      headerRow.appendChild(th2);
      if (isEditing) {
        const th3 = document.createElement('th');
        th3.className = 'checkbox-cell';
        headerRow.appendChild(th3);
      }
      schemaTable.appendChild(headerRow);

      const maxLength = Math.max(headers1.length, headers2.length);
      for (let i = 0; i < maxLength; i++) {
        const row = document.createElement('tr');
        const td1 = document.createElement('td');
        const td2 = document.createElement('td');
        td1.innerHTML = headers1[i] ? `${headers1[i]}${headers1[i] === comparisonKey ? '<span class="key-icon">🔑</span>' : ''}` : '';
        td2.innerHTML = headers2[i] ? `${headers2[i]}${headers2[i] === comparisonKey ? '<span class="key-icon">🔑</span>' : ''}` : '';
        if (headers1[i] && uniqueToFile1.includes(headers1[i])) {
          td1.classList.add('different');
        }
        if (headers2[i] && uniqueToFile2.includes(headers2[i])) {
          td2.classList.add('different');
        }
        row.appendChild(td1);
        row.appendChild(td2);
        if (isEditing && headers2[i] && commonHeaders.includes(headers2[i])) {
          const td3 = document.createElement('td');
          td3.className = 'checkbox-cell';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = headers2[i] === (selectedKey || comparisonKey);
          checkbox.onchange = () => {
            if (checkbox.checked) {
              document.querySelectorAll('.schema-table input[type="checkbox"]').forEach(cb => {
                if (cb !== checkbox) cb.checked = false;
              });
              selectedKey = headers2[i];
            } else {
              selectedKey = null;
            }
          };
          td3.appendChild(checkbox);
          row.appendChild(td3);
        } else if (isEditing) {
          row.appendChild(document.createElement('td'));
        }
        schemaTable.appendChild(row);
      }

      comparisonKeyDiv.innerHTML = isEditing ? '' : `Edit the key column <span class="edit-icon" onclick="toggleEditMode()">✎</span>`;
    }

    function toggleEditMode() {
      isEditing = !isEditing;
      selectedKey = null;
      if (data1 && data2) {
        const headerComparison = compareHeaders(
          Object.keys(data1[0] || {}),
          Object.keys(data2[0] || {}),
          'Old File',
          'New File'
        );
        updateSchema(
          Object.keys(data1[0] || {}),
          Object.keys(data2[0] || {}),
          headerComparison.uniqueToFile1 || [],
          headerComparison.uniqueToFile2 || [],
          headerComparison.commonHeaders || []
        );
      }
    }

    function renderDataTable(data, headers, tableId, searchTerm = '', isNewData = false) {
      const dataTable = document.getElementById(tableId);
      dataTable.innerHTML = '';

      const headerRow = document.createElement('tr');
      headers.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        headerRow.appendChild(th);
      });
      dataTable.appendChild(headerRow);

      let filteredData = searchTerm
        ? data.filter(row => 
            Object.values(row).some(value => 
              value && value.toString().toLowerCase().includes(searchTerm.toLowerCase())
            )
          )
        : data;

      if (isNewData && data1 && comparisonKey && headers.includes(comparisonKey)) {
        const oldDataByKey = new Map(data1.map(row => [row[comparisonKey], row]));
        let rowsToDisplay = [];

        if (showModifiedOnly) {
          const modifiedRows = filteredData.filter(row => {
            const oldRow = oldDataByKey.get(row[comparisonKey]);
            if (!oldRow) return true; // New row
            return headers.some(header => 
              header !== comparisonKey && oldRow[header] !== row[header]
            );
          });
          rowsToDisplay.push(...modifiedRows);
        } else {
          rowsToDisplay.push(...filteredData);
        }

        if (showDeletedOnly) {
          const newDataKeys = new Set(filteredData.map(row => row[comparisonKey]));
          const deletedRows = data1.filter(row => !newDataKeys.has(row[comparisonKey])).filter(row =>
            searchTerm ? Object.values(row).some(value =>
              value && value.toString().toLowerCase().includes(searchTerm.toLowerCase())
            ) : true
          );
          rowsToDisplay.push(...deletedRows);
        }

        rowsToDisplay.forEach(row => {
          const dataRow = document.createElement('tr');
          const isNewRow = !oldDataByKey.has(row[comparisonKey]);
          const isDeletedRow = !filteredData.some(r => r[comparisonKey] === row[comparisonKey]);

          if (isNewRow) {
            dataRow.classList.add('new-row');
          } else if (isDeletedRow) {
            dataRow.classList.add('deleted-row');
          }

          headers.forEach(header => {
            const td = document.createElement('td');
            let cellContent = row[header] || '';
            if (searchTerm && cellContent) {
              const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
              cellContent = cellContent.toString().replace(regex, '<span class="highlight">$1</span>');
            }
            td.innerHTML = cellContent;
            if (!isNewRow && !isDeletedRow && header !== comparisonKey) {
              const oldRow = oldDataByKey.get(row[comparisonKey]);
              if (oldRow && oldRow[header] !== row[header]) {
                td.classList.add('different-value');
              }
            }
            dataRow.appendChild(td);
          });
          dataTable.appendChild(dataRow);
        });
      } else {
        filteredData.forEach(row => {
          const dataRow = document.createElement('tr');
          headers.forEach(header => {
            const td = document.createElement('td');
            let cellContent = row[header] || '';
            if (searchTerm && cellContent) {
              const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
              cellContent = cellContent.toString().replace(regex, '<span class="highlight">$1</span>');
              td.innerHTML = cellContent;
            } else {
              td.textContent = cellContent;
            }
            dataRow.appendChild(td);
          });
          dataTable.appendChild(dataRow);
        });
      }
    }

    function exportToCSV(headers, searchTerm) {
      if (!data2 || !headers.includes(comparisonKey)) {
        updateMessages(['No data or valid comparison key available for export.'], true);
        return;
      }

      try {
        const oldDataByKey = new Map(data1.map(row => [row[comparisonKey], row]));
        let rowsToExport = [];

        let filteredData = searchTerm
          ? data2.filter(row => 
              Object.values(row).some(value => 
                value && value.toString().toLowerCase().includes(searchTerm.toLowerCase())
              )
            )
          : data2;

        if (showModifiedOnly) {
          const modifiedRows = filteredData.filter(row => {
            const oldRow = oldDataByKey.get(row[comparisonKey]);
            if (!oldRow) return true; // New row
            return headers.some(header => 
              header !== comparisonKey && oldRow[header] !== row[header]
            );
          });
          rowsToExport.push(...modifiedRows);
        } else {
          rowsToExport.push(...filteredData);
        }

        if (showDeletedOnly) {
          const newDataKeys = new Set(filteredData.map(row => row[comparisonKey]));
          const deletedRows = data1.filter(row => !newDataKeys.has(row[comparisonKey])).filter(row =>
            searchTerm ? Object.values(row).some(value =>
              value && value.toString().toLowerCase().includes(searchTerm.toLowerCase())
            ) : true
          );
          rowsToExport.push(...deletedRows);
        }

        if (rowsToExport.length === 0) {
          updateMessages(['No rows to export based on current view.'], true);
          return;
        }

        // Function to escape CSV values
        function escapeCSVValue(value) {
          if (value == null) return '';
          const str = value.toString();
          if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            return `"${str.replace(/"/g, '""')}"`;
          }
          return str;
        }

        // Generate CSV
        const csvRows = [];
        // Add headers
        csvRows.push(headers.map(escapeCSVValue).join(','));
        // Add data rows
        rowsToExport.forEach(row => {
          const rowData = headers.map(header => escapeCSVValue(row[header] || ''));
          csvRows.push(rowData.join(','));
        });
        const csvContent = csvRows.join('\n');

        // Trigger download
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `exported_data_${timestamp}.csv`;
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } catch (error) {
        updateMessages([`Export failed: ${error.message}`], true);
      }
    }

    async function readExcelFile(file) {
      try {
        await loadSheetJS(); // Ensure SheetJS is loaded
        const arrayBuffer = await file.arrayBuffer();
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];

        const range = XLSX.utils.decode_range(worksheet['!ref']);
        const headers = [];
        const firstRow = [];

        for (let col = range.s.c; col <= range.e.c; col++) {
          const cellAddress = XLSX.utils.encode_cell({ r: range.s.r, c: col });
          const cell = worksheet[cellAddress];
          const value = cell ? cell.v : '';
          if (value !== '' && value !== null && value !== undefined) {
            headers.push(value.toString());
          } else {
            headers.push(null);
          }
          firstRow.push(value);
        }

        const validHeaders = headers.filter(h => h !== null);

        const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
          header: validHeaders, 
          defval: '',
          range: { s: { c: range.s.c, r: range.s.r + 1 }, e: { c: range.e.c, r: range.e.r } }
        });

        const mappedData = jsonData.map(row => {
          const newRow = {};
          validHeaders.forEach(header => {
            newRow[header] = row[header] || '';
          });
          return newRow;
        });

        return { data: mappedData, headers: validHeaders };
      } catch (error) {
        throw new Error(`Error reading ${file.name}: ${error.message}`);
      }
    }

    function compareHeaders(headers1, headers2, fileName1, fileName2) {
      const uniqueToFile1 = headers1.filter(h => !headers2.includes(h));
      const uniqueToFile2 = headers2.filter(h => !headers1.includes(h));
      const commonHeaders = headers1.filter(h => headers2.includes(h));

      if (!comparisonKey || !commonHeaders.includes(comparisonKey)) {
        comparisonKey = commonHeaders.includes('Name') ? 'Name' : commonHeaders[0] || null;
      }

      if (uniqueToFile1.length === 0 && uniqueToFile2.length === 0) {
        return { isConsistent: true, uniqueToFile1: [], uniqueToFile2: [], commonHeaders };
      }

      const messages = ['Warning: The uploaded files have different column headers.'];
      
      if (uniqueToFile1.length > 0) {
        messages.push({
          message: `Old file (${fileName1}) contains columns not present in the new file: ${uniqueToFile1.join(', ')}.`,
          isDetail: true
        });
      }
      
      if (uniqueToFile2.length > 0) {
        messages.push({
          message: `New file (${fileName2}) contains columns not present in the old file: ${uniqueToFile2.join(', ')}.`,
          isDetail: true
        });
      }

      return { isConsistent: false, messages, uniqueToFile1, uniqueToFile2, commonHeaders };
    }

    async function processFiles() {
      const fileInput1 = document.getElementById('file1');
      const fileInput2 = document.getElementById('file2');

      if (!fileInput1.files.length || !fileInput2.files.length) {
        updateMessages(['Please upload both Excel files.'], true);
        document.getElementById('schema').classList.remove('processed');
        document.getElementById('check1').style.display = 'none';
        document.getElementById('check2').style.display = 'none';
        hideDataView();
        toggleDataTab(false);
        return;
      }

      try {
        const file1Result = await readExcelFile(fileInput1.files[0]);
        const file2Result = await readExcelFile(fileInput2.files[0]);
        data1 = file1Result.data;
        data2 = file2Result.data;

        document.getElementById('check1').style.display = 'inline';
        document.getElementById('check2').style.display = 'inline';

        const headerComparison = compareHeaders(
          file1Result.headers,
          file2Result.headers,
          fileInput1.files[0].name,
          fileInput2.files[0].name
        );

        updateSchema(
          file1Result.headers,
          file2Result.headers,
          headerComparison.uniqueToFile1 || [],
          headerComparison.uniqueToFile2 || [],
          headerComparison.commonHeaders || []
        );

        if (!headerComparison.isConsistent) {
          updateMessages(headerComparison.messages, false, true);
        } else {
          updateMessages([]);
        }

        toggleDataTab(true);
        renderSubTabData('OldData');

        console.log('File 1 Data:', data1);
        console.log('File 2 Data:', data2);
      } catch (error) {
        updateMessages([error.message], true);
        document.getElementById('schema').classList.remove('processed');
        document.getElementById('check1').style.display = 'none';
        document.getElementById('check2').style.display = 'none';
        hideDataView();
        toggleDataTab(false);
      }
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.stopPropagation();
      e.currentTarget.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      e.preventDefault();
      e.stopPropagation();
      e.currentTarget.classList.remove('drag-over');
    }

    function handleDrop(e, fileInputId) {
      e.preventDefault();
      e.stopPropagation();
      e.currentTarget.classList.remove('drag-over');

      const files = e.dataTransfer.files;
      if (files.length > 0 && files[0].name.endsWith('.xlsx')) {
        const fileInput = document.getElementById(fileInputId);
        fileInput.files = files;
        const changeEvent = new Event('change', { bubbles: true });
        fileInput.dispatchEvent(changeEvent);
      }
    }

    document.getElementById('file1').addEventListener('change', function() {
      const checkMark = document.getElementById('check1');
      checkMark.style.display = this.files.length > 0 ? 'inline' : 'none';
      hideDataView();
      if (this.files.length > 0 && document.getElementById('file2').files.length > 0) {
        processFiles();
      }
    });

    document.getElementById('file2').addEventListener('change', function() {
      const checkMark = document.getElementById('check2');
      checkMark.style.display = this.files.length > 0 ? 'inline' : 'none';
      hideDataView();
      if (this.files.length > 0 && document.getElementById('file1').files.length > 0) {
        processFiles();
      }
    });

    document.getElementById('oldDataSearch').addEventListener('input', function() {
      if (data1) {
        const headers = Object.keys(data1[0] || {});
        renderDataTable(data1, headers, 'oldDataTable', this.value);
      }
    });

    document.getElementById('newDataSearch').addEventListener('input', function() {
      if (data2) {
        const headers = Object.keys(data2[0] || {});
        renderDataTable(data2, headers, 'newDataTable', this.value, true);
      }
    });

    document.getElementById('modifiedFilter').addEventListener('click', function() {
      showModifiedOnly = !showModifiedOnly;
      this.classList.toggle('active');
      renderSubTabData('NewData');
    });

    document.getElementById('deletedFilter').addEventListener('click', function() {
      showDeletedOnly = !showDeletedOnly;
      this.classList.toggle('active');
      renderSubTabData('NewData');
    });

    document.getElementById('exportButton').addEventListener('click', function() {
      if (data2) {
        const headers = Object.keys(data2[0] || {});
        const searchTerm = document.getElementById('newDataSearch').value;
        exportToCSV(headers, searchTerm);
      } else {
        updateMessages(['No data available to export.'], true);
      }
    });

    const dragArea1 = document.getElementById('dragArea1');
    const dragArea2 = document.getElementById('dragArea2');

    dragArea1.addEventListener('dragover', handleDragOver);
    dragArea1.addEventListener('dragleave', handleDragLeave);
    dragArea1.addEventListener('drop', (e) => handleDrop(e, 'file1'));

    dragArea2.addEventListener('dragover', handleDragOver);
    dragArea2.addEventListener('dragleave', handleDragLeave);
    dragArea2.addEventListener('drop', (e) => handleDrop(e, 'file2'));
  </script>
</body>
</html>